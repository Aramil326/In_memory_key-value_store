Реализация хранилища ключей и значений в памяти для хранения различных данных о финансовых транзакциях на C++ в виде
консольного приложения.

# Примененные технологии
- C++ стандарта C++17
- clang-format
- Makefile
- gcc
- gtest

# Примененные паттерны
- MVC

## Содержание

1. [Вступление](#Вступление)
2. [Вступление](#Вступление)
3. [Part 1](#part-1-реализация-in-memory-key-value-хранилища-на-базе-хеш-таблицы)
4. [Part 2](#part-2-реализация-in-memory-key-value-хранилища-на-базе-самобалансирующегося-бинарного-дерева-поиска)
5. [Part 3](#part-3-реализация-консольного-интерфейса)


## Вступление

В рамках данного проекта нам предстояло освежить в памяти и более детально изучить структуры данных, такие как
хеш-таблицы и самобалансирующиеся бинарные деревья. Кроме того, мы должны были создать хранилище типа ключ-значение на
основе этих структур данных.

## Информация

### Описание структуры данных

В качестве ключа в хранилище типа ключ-значение будут использоваться строки. Что касается значений, то в этом хранилище
будут храниться записи о студентах Школы 21 в следующем формате:

* Фамилия
* Имя
* Год рождения
* Город
* Число текущих коинов

### Описание реализуемых функций key-value хранилища

### SET

Эта команда предназначена для установки ключа и его соответствующего значения. В приведенном ниже примере ключом
является строка `foo`, а значение представляет собой ранее описанную структуру. Значения полей новой записи вводятся в
соответствии с их описанием в структуре. В качестве дополнительного параметра можно использовать EX, чтобы указать срок
действия создаваемой записи. Если не указан необязательный параметр, то по умолчанию время жизни записи не ограничено.

Описание параметров команды `SET`:

```
SET <ключ> <Фамилия> <Имя> <Год рождения> <Город> <Число текущих коинов> EX <время в секундах>
```

Пример использования команды `SET` для создания записи без ограничения на время её существования:

```
SET foo Иванов Иван 2001 Казань 5 
> OK
SET foo Иванов Иван aaaa Казань 5 
> ERROR: unable to cast value "aaaa" to type int 
```

Вот пример использования команды `SET` для создания записи с ограничением на время её существования. В данном случае
запись будет существовать в течение 10 секунд и автоматически удалится после истечения этого времени:

```
SET foo Иванов Иван 2001 Казань 5 EX 10 
> OK
```

### GET

Эта команда служит для извлечения значения, связанного с определенным ключом. В случае отсутствия записи с таким ключом,
будет возвращено значение `(null)`:

```
GET foo
> Иванов Иван 2001 Казань 5  
GET unknownkey
> (null)
```

### EXISTS

Данная команда выполняет проверку наличия записи с указанным ключом. Если объект существует, она вернет `true`, в
противном случае - `false`:

```
EXISTS foo
> true
```

### DEL

Эта команда удаляет ключ и связанное с ним значение, а затем возвращает `true`, если операция удаления выполнена
успешно, и `false`, если запись не была найдена и, соответственно, не была удалена:

```
DEL foo
> true
```

### UPDATE

Данная команда обновляет значение, связанное с указанным ключом, если такой ключ уже существует:

```
SET foo Вас И 20 Мос 5 
> OK
UPDATE foo Иванов Иван 2001 Казань 5
> OK

GET foo
> Иванов Иван 2001 Казань 5
```

Если нет планов изменять какое-либо поле, то вместо него можно поставить прочерк "-" для обозначения отсутствия
изменений:

```
SET foo Вас И 20 Мос 5 
> OK
UPDATE foo Васильев - - - 5
> OK

GET foo
> Васильев И 20 Мос 55 
```

### KEYS

Возвращает все ключи, которые находятся в хранилище:

```
KEYS
1) boo
2) foo
3) bar
```

### RENAME

Команда для переименования ключей:

```
RENAME foo foo2
> OK

GET foo
> (null)

GET foo2
> Васильев И 20 Мос 55 
```

### TTL

Если ключ установлен с определенным временным сроком действия, то данную команду можно использовать для получения
информации об оставшемся времени. Если записи с указанным ключом не существует, то будет возвращено значение `(null)`:

```
SET Иванов Иван 2001 Казань 5 EX 10
> OK
TTL foo
> 6
TTL foo
> 5
TTL foo
> 4
TTL foo
> (null)
```

### FIND

Эту команду можно применять для поиска ключа (или ключей), связанных с определенным значением. Аналогично
команде `UPDATE`, необязательно указывать все значения из структуры студентов Школы 21. Если какие-либо поля не
участвуют в поиске, их можно обозначить прочерком `-`.

Пример использования команды `FIND`:

```
FIND Иванов Иван 2001 Казань 5
> 1) foo
FIND Васильев Антон 1997 Тверь 55
> 1) boo
```

Пример использования команды `FIND` с поиском по фамилии и числу коинов:

```
FIND Васильев - - - 5
> 1) foo
> 2) boo
```

### SHOWALL

Эта команда предназначена для извлечения всех записей, которые находятся в хранилище key-value:

```
SHOWALL
> № | Фамилия |   Имя   | Год |  Город   | Количество коинов |
> 1 "Иванов"    "Иван"    2001  "Москва"          5 
> 2  "Иванов"  "Василий"  2000  "Москва"          55 
```

### UPLOAD

Эта команда служит для импорта данных из файла. Файл содержит список данных, которые необходимо загрузить, и имеет
следующий формат:

```
key1 "Васильев" "Иван" 2001 "Ростов" 55
key2 "Иванов" "Василий" 2000 "Москва" 55 
...
key101 "Сидоров" "Сергей" 1847 "Суздаль" 12312313 
```

Вызов команды:

```
UPLOAD ~/Desktop/TestData/file.dat
> OK 101
```

После ответа `OK` выводится число загруженных строк из файла.

### EXPORT

Эта команда используется для экспорта данных, которые в данный момент находятся в хранилище key-value, в файл. Файл,
созданный в результате этой команды, будет содержать список данных в следующем формате:

```
key1 "Васильев" "Иван" 2001 "Ростов" 55
key2 "Иванов" "Василий" 2000 "Москва" 55 
...
key101 "Сидоров" "Сергей" 1847 "Суздаль" 12312313 
```

Вызов команды:

```
EXPORT ~/Desktop/TestData/export.dat
> OK 101
```

После ответа `OK` выводится число выгруженных строк из файла.

## Chapter III

## Part 1. Реализация in-memory key-value хранилища на базе хеш-таблицы

Необходимо реализовать in-memory key-value хранилище на основе хеш-таблицы:

- Необходимо создать программу на языке C++ стандарта C++17.
- Код программы должен находиться в каталоге src.
- При написании кода следует соблюдать стиль Google.
- Классы должны быть определены в пространстве имен s21.
- Использование устаревших и вышедших из употребления конструкций языка и библиотек запрещено.
- Программное решение следует представить в виде статической библиотеки с заголовочным файлом hash_table.h.
- Библиотека должна включать класс HashTable, который хранит данные в виде хеш-таблицы и предоставляет все необходимые
  методы для реализации описанного функционала.
- Выбор хеш-функции и метода разрешения коллизий остается на ваше усмотрение.
- Класс HashTable должен быть наследником базового абстрактного класса, который включает все методы, перечисленные выше.
- Необходимо предусмотреть Makefile для сборки библиотеки и тестов с целями all, clean, tests, hash_table.a.
- Обеспечение полного покрытия unit-тестами методов класса HashTable обязательно.

## Part 2. Реализация in-memory key-value хранилища на базе самобалансирующегося бинарного дерева поиска

Необходимо реализовать in-memory key-value хранилище на основе самобалансирующегося бинарного дерева поиска:

- Программа должна быть создана на языке C++ стандарта C++17.
- Код программы должен располагаться в каталоге src.
- При разработке кода необходимо соблюдать стиль оформления Google.
- Классы должны быть реализованы в пространстве имен `s21`.
- Использование устаревших и вышедших из употребления конструкций языка и библиотек запрещено.
- Решение должно быть оформлено в виде статической библиотеки с заголовочным файлом self_balancing_binary_search_tree.h.
- Библиотека должна включать класс SelfBalancingBinarySearchTree, который хранит данные в виде самобалансирующегося
  бинарного дерева поиска и предоставляет все необходимые методы для реализации описанного функционала.
- Выбор типа самобалансирующегося бинарного дерева поиска остается на ваше усмотрение.
- Класс SelfBalancingBinarySearchTree должен быть наследником базового абстрактного класса, который включает все методы,
  перечисленные ранее.
- Добавьте цель "self_balancing_binary_search_tree.a" в существующий Makefile для сборки библиотеки.
- Необходимо обеспечить полное покрытие unit-тестами методов класса SelfBalancingBinarySearchTree.

## Part 3. Реализация консольного интерфейса

Программа должна предоставлять пользователю консольный интерфейс с опциями, включая:

Первоначальный выбор типа хранилища:

1. Хеш-таблица
2. Самобалансирующееся бинарное дерево поиска
   Возможность ввода команд для работы с выбранным типом хранилища. Команды должны включать функционал, описанный выше
   для хранилища типа ключ-значение.
